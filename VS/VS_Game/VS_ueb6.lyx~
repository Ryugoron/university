#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Verteilte Systeme Übung Nr.
 6/7
\end_layout

\begin_layout Author
Alexander Steen , Max Wisniewski
\end_layout

\begin_layout Date
Tutor : Philipp Schmidt
\end_layout

\begin_layout Subsection*
Vorbereitung
\end_layout

\begin_layout Standard
Da wir in den letzen 2 Wochen viel zu tun hatten, haben wir unsere letzte
 Version nicht nocheinmal abgeändert, sondern haben diese einfach weiter
 verwendet.
 Da wir Schiffe und andocken schon implementiert hatten, haben wir das Protokoll
 in diesen Punkten nicht nocheinmal angepasst.
\end_layout

\begin_layout Standard
Dadurch haben wir aber keine allgemeine Kompatibilität zum vorgeschlagenen
 Protokoll mehr, aber innerhalb unserer Implementierung funkioniert alles
 wie gefordert.
\end_layout

\begin_layout Subsection*
Aufgabe
\end_layout

\begin_layout Standard
In der Aufgabe 6 sollte man das Spiel vom letzten mal um zwei Befehle erweitern.
 Dies ist zum einen der Befehl 
\series bold
goods
\series default
.
 Wird dieser aufgrerufen, sollen alle verfügbaren Waren im bekannten Universum
 zurückgeliefert werden.
\end_layout

\begin_layout Standard
Der zweite Befehl ist 
\series bold
costs
\series default
, der einem von einem angegebenen Planeten ausgibt, wie viel einer bestimmten
 Ware vorrätig ist und zu welchem Preis diese vorhanden ist.
\begin_inset Newline newline
\end_inset

In Aufgabe 7 sollten wir nun endlich Handeln können.
 Dazu muss das Schiff von einem Planeten zum anderen reisen können.
 Dazu brauchen wir das 
\series bold
travel
\series default
 command, dies kann mit mittels dock, kcod und undock den Planeten wechseln.
\end_layout

\begin_layout Standard
Danach brauchen wir noch 
\series bold
sell, buy, (yub, lles)
\series default
 um den eigentlichen kauf zu realisieren.
\begin_inset Newline newline
\end_inset

Zur besseren Bedienung haben wir noch 
\series bold
status 
\series default
[gibt Geld, Position und Waren aus], 
\series bold
drop
\series default
 [schmeißt eine Ware weg] und 
\series bold
path
\series default
 [gibt den Weg zu einem Planeten auf].
 Diese Befehle an sich sind nicht schwer zu implementieren und werden hier
 deswegen nicht näher erklärt.
\end_layout

\begin_layout Subsection*
Implementierung
\end_layout

\begin_layout Standard
Beim letzten mal haben wir unser Framework für das Programm vorgestellt.
 Wir haben es so angepasst, dass wir unsere Klassen 
\series bold
Planet
\series default
 und 
\series bold
Ship
\series default
 nur noch eine Message- oder Commandinterface implementieren lassen müssen
 und schon werden die betreffenden Nachricht empfangen und entsprechend
 geparsed.
\end_layout

\begin_layout Standard
Wir müssen uns diesmal also nur noch um die konkrete Umsetzung kümmern.
 Betrachten wir ersteinmal unsere Waren
\end_layout

\begin_layout Subsubsection*
Market
\end_layout

\begin_layout Standard
Durch den Market müssen wir uns später beim Kauf und Verkauf von Waren nicht
 mehr um die genaue Umsetzung von Preisen kümmern.
 Wir speichern hier auch alle Waren, die wir persönlich im Markt anbieten.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},numbers=left,tabsize=3"
inline false
status open

\begin_layout Plain Layout

public class Market {
\end_layout

\begin_layout Plain Layout

	private Map<String, Integer> value = new HashMap<String, Integer>();
\end_layout

\begin_layout Plain Layout

	private Map<String, Integer> need = new HashMap<String, Integer>();
\end_layout

\begin_layout Plain Layout

	private Map<String, Integer> capa = new HashMap<String, Integer>();
\end_layout

\begin_layout Plain Layout

	private Map<String, Integer> ttl = new HashMap<String, Integer>();
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

	public void newGood(String name, int value, int need, int ttl) {
\end_layout

\begin_layout Plain Layout

		this.value.put(name, value);
\end_layout

\begin_layout Plain Layout

		this.need.put(name, need);
\end_layout

\begin_layout Plain Layout

		this.ttl.put(name, ttl);
\end_layout

\begin_layout Plain Layout

		this.capa.put(name, 0);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void delGood(String name) {
\end_layout

\begin_layout Plain Layout

		this.value.remove(name);
\end_layout

\begin_layout Plain Layout

		this.need.remove(name);
\end_layout

\begin_layout Plain Layout

		this.ttl.remove(name);
\end_layout

\begin_layout Plain Layout

		this.capa.remove(name);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public int price(String name) {
\end_layout

\begin_layout Plain Layout

		if(this.capa.get(name)==0) return this.value.get(name) *
\end_layout

\begin_layout Plain Layout

				this.need.get(name) * 2;
\end_layout

\begin_layout Plain Layout

		return this.value.get(name) 				
\end_layout

\begin_layout Plain Layout

			* (this.need.get(name) / this.capa.get(name));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public int amount(String name){
\end_layout

\begin_layout Plain Layout

		return this.capa.get(name);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public int ttl(String name){
\end_layout

\begin_layout Plain Layout

		return this.ttl.get(name);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public Set<String> allGoods() {
\end_layout

\begin_layout Plain Layout

		return this.value.keySet();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public int buy(String name, int amount) {
\end_layout

\begin_layout Plain Layout

		if(this.capa.get(name) <= 0) return 0;
\end_layout

\begin_layout Plain Layout

		int price = this.price(name);
\end_layout

\begin_layout Plain Layout

		int realAmount = this.capa.get(name) < amount ? this.capa.get(name) : amount;
\end_layout

\begin_layout Plain Layout

		this.capa.put(name, this.capa.get(name)-realAmount);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		return price*realAmount + 1;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public int sell(String name, int amount) {
\end_layout

\begin_layout Plain Layout

		if(this.need.get(name) <= 0) return 0;
\end_layout

\begin_layout Plain Layout

		int price = this.price(name);
\end_layout

\begin_layout Plain Layout

		this.capa.put(name, this.capa.get(name) + amount);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		return price*amount + 1;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Die Implementierung des Market
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wir können hier im Market einfach neue Waren erschaffen.
 Dazu brauchen wir einen Bedarf an Waren, einen Standardpreis, eine TimeToLife
 und einen Namen.
 In einer weiteren Methode können wir schon einmal eine Startmenge anlegen.
 Die Berechnung für den eigentlichen Preis ist reichlich willkürlich, aber
 erfüllte unsere Forderungen an einen Preis für Angebot und Nachrfrage.
\end_layout

\begin_layout Subsubsection*
Goods
\end_layout

\begin_layout Standard
Um goods zu Implementieren müssen wir 2 Seiten betrachten.
 Einmal die Planeten, die diese Nachrichten weiterleiten und immer aktuell
 halten müssen, und zum anderen die Schiffe, die diese Informationen benötigen
 um anständig Handl treiben zu können.
\end_layout

\begin_layout Standard
Betrachten wir das ganze ersteinmal von der Planetenseite aus:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},numbers=left,tabsize=3"
inline false
status open

\begin_layout Plain Layout

public void onTick() {
\end_layout

\begin_layout Plain Layout

	for (String good : this.rechableGoods.keySet()) {
\end_layout

\begin_layout Plain Layout

		int ttl = this.rechableGoods.get(good) - 1;
\end_layout

\begin_layout Plain Layout

		if ((this.market.isGood(good) && ttl < this.market.ttl(good))) {
\end_layout

\begin_layout Plain Layout

			this.rechableGoods.put(good, this.market.ttl(good));
\end_layout

\begin_layout Plain Layout

		} else {
\end_layout

\begin_layout Plain Layout

			this.rechableGoods.put(good, this.rechableGoods.get(good));
\end_layout

\begin_layout Plain Layout

			if (ttl == 0)
\end_layout

\begin_layout Plain Layout

				this.rechableGoods.remove(good);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	Message m = GameMessage.GOODS.toMessage(this.sendGoods());
\end_layout

\begin_layout Plain Layout

	for (Channel c : this.connectedPeers.values()) {
\end_layout

\begin_layout Plain Layout

		c.send(m);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public void onSdoog(Channel c, String[] goods) {
\end_layout

\begin_layout Plain Layout

	String oMessage = GameMessage.SDOOG.toString();
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < goods.length; ++i) {
\end_layout

\begin_layout Plain Layout

		oMessage += " " + goods[i];
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	this.con.println(StdFd.Messages, oMessage);
\end_layout

\begin_layout Plain Layout

	this.updateReachableGoods(goods);
\end_layout

\begin_layout Plain Layout

	this.updatePlanetList();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public void onGoods(Channel c, String[] goods) {
\end_layout

\begin_layout Plain Layout

	String oMessage = GameMessage.GOODS.toString();
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < goods.length; ++i) {
\end_layout

\begin_layout Plain Layout

		oMessage += " " + goods[i];
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	this.con.println(StdFd.Messages, oMessage);
\end_layout

\begin_layout Plain Layout

	this.updateReachableGoods(goods);
\end_layout

\begin_layout Plain Layout

	c.send(GameMessage.SDOOG.toMessage(this.sendGoods()));
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
goods from Planet
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wir haben uns als aller erstes um die Waren einigermaßen auf dem neusten
 Stand zu halten einen Timer geschrieben, der den Planeten nach 
\emph on
intervall
\emph default
 Zeiteinheiten (bei uns 10s) benachrichtigt, dass er seine Nachbarn nach
 
\series bold
GOODS
\series default
 fragt.
 Am Anfang jeder Runde zählen wir die 
\series bold
ttl
\series default
 einer Ware herunter, außer wenn die ttl unter die in unserem Markt fällt
 oder die ttl 0 ist, dann entfernen wir die Ware.
\end_layout

\begin_layout Standard
Zu beachten in der Implementierung ist.
 Dass wir nicht den gesammten Graphen fluten.
 Dies führt dazu, dass 
\series bold
GOODS
\series default
 erst nach einiger Zeit die Änderung von Waren an den gesammten Graphen
 übermittelt hat.
\end_layout

\begin_layout Standard
Dies führt bei uns zu 2 Beobachtungen.
 Erstens braucht es 
\begin_inset Formula $diam\left(\text{Graph}\right)$
\end_inset

 Runden, bis eine neue Ware den gesammten Graphen erreicht hat (unter der
 Vorraussetzung, dass die ttl groß genug ist um den gesammten Graphen zu
 erreichen) [diam steht für den Durchmesser des Graphen, also den längsten
 der Kürzesten Wege eines Graphen von einem Knoten zum anderen].
 Zweitens brauchen wir nach dem auslöschen einer Ware 
\begin_inset Formula $diam\left(\text{Graph}\right)+ttl$
\end_inset

 Runden, damit der letzte dieses verschwinden bemerkt.
 Dies gilt natürlich nur, wenn auf dem Weg die Ware nicht mehr vorhanden
 ist.
\begin_inset VSpace defskip
\end_inset

Wir haben uns dafür entschieden, weil die Benutzung sehr viel leichter ist,
 als jedes mal den gesammten Graphen zu fluten.
 Es verursacht pro Runde eine sehr viel kleinere Menge an Nachrichten die
 ausgetauscht wird.
\end_layout

\begin_layout Standard
Dies alles ist nur Sinnvoll, durch die Überlegung, das die Waren, die angeboten
 werden, sich nicht allzuschnell ändern werden.
 Was sich schnell Ändern kann sind die Preise.
 Da die Waren an sich für lange Zeit bestehen werden, wird auch unser gesammter
 Zustand im Graphen die größte Teil konsitent sein.
 Die Schwerfälligkeit bei Veränderungen zahlt sich aber spätestens bei der
 Reaktion in bestehenden Systemen aus.
 Gerade wenn Schiffe sehr viel Reisen und anfragen.
\end_layout

\begin_layout Subsubsection*
Costs
\end_layout

\begin_layout Standard
Da sich die Preise von Waren recht schnell Ändern können, benötigen wir
 einen anderen Ansatz als bei 
\series bold
GOODS
\series default
.
 Die Preise im Cache zu halten lohnt sich also nicht, wie bei den bisherigen
 Möglichkeiten.
\end_layout

\begin_layout Standard
Um den Preis zu erfragen, verwenden wir das Softwarerouting, das uns das
 
\series bold
PEERS
\series default
 ermöglicht:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},numbers=left,tabsize=3"
inline false
status open

\begin_layout Plain Layout

public void onTsoc(String[] way, String good, int price, int amount) {
\end_layout

\begin_layout Plain Layout

	if (way[way.length - 2].equals(this.name)) {
\end_layout

\begin_layout Plain Layout

		//Konstruiere Message way ...
\end_layout

\begin_layout Plain Layout

		Message m = GameMessage.TSOC.toMessage(way);
\end_layout

\begin_layout Plain Layout

		this.dockedShips.get(way[way.length - 1]).send(m);
\end_layout

\begin_layout Plain Layout

	} else {
\end_layout

\begin_layout Plain Layout

		int pos = this.search(way, this.name);
\end_layout

\begin_layout Plain Layout

		if (pos >= 0) {
\end_layout

\begin_layout Plain Layout

			//Konstrukt Message way ...
\end_layout

\begin_layout Plain Layout

			Message m = GameMessage.COST.toMessage(way);
\end_layout

\begin_layout Plain Layout

			this.connectedPeers.get(way[pos + 1]).send(m);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public void onCost(String[] way, String good) {
\end_layout

\begin_layout Plain Layout

	if (way[way.length - 1].equals(this.name)) {
\end_layout

\begin_layout Plain Layout

		// Wir sind die angefragten
\end_layout

\begin_layout Plain Layout

		if (this.market.isGood(good)) {
\end_layout

\begin_layout Plain Layout

			int price = this.market.price(good);
\end_layout

\begin_layout Plain Layout

			int amount = this.market.amount(good);
\end_layout

\begin_layout Plain Layout

			String[] msg = new String[way.length + 5];
\end_layout

\begin_layout Plain Layout

			//Konstrukt Message way
\end_layout

\begin_layout Plain Layout

			Message m = GameMessage.TSOC.toMessage(msg);
\end_layout

\begin_layout Plain Layout

			if (this.dockedShips.containsKey(msg[1])) {
\end_layout

\begin_layout Plain Layout

				this.dockedShips.get(msg[1]).send(m);
\end_layout

\begin_layout Plain Layout

			} else {
\end_layout

\begin_layout Plain Layout

				this.connectedPeers.get(msg[1]).send(m);
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	} else {
\end_layout

\begin_layout Plain Layout

		int pos = this.search(way, this.name);
\end_layout

\begin_layout Plain Layout

		if (pos >= 0) {
\end_layout

\begin_layout Plain Layout

			way = this.invertInTo(new String[way.length + 2], way);
\end_layout

\begin_layout Plain Layout

			way[way.length] = "#";
\end_layout

\begin_layout Plain Layout

			way[way.length + 1] = good;
\end_layout

\begin_layout Plain Layout

			Message m = GameMessage.COST.toMessage(way);
\end_layout

\begin_layout Plain Layout

			this.connectedPeers.get(way[pos + 1]).send(m);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
goods leitet die Anfrage durch den Graphen
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wenn wir eine Nachricht 
\series bold
COST
\series default
 bekommen, schauen wir nach, ob wir der eientliche Empfänger dieser Nachricht.
 Sind wir es, packen wir hinten an die Nachricht den Preis und die Menge
 ran und schicken sie den Weg zurück.
\end_layout

\begin_layout Standard
Sind wir in der Mitte des Weges verhalten sich 
\series bold
COST 
\series default
und 
\series bold
TSOC
\series default
 gleich.
 Sie schicken es einfach an den nächsten in der Liste weiter.
\end_layout

\begin_layout Standard
Bei 
\series bold
TSOC
\series default
 müssen wir nur noch darauf achten, dass wir der vorletzte in der Liste
 sind.
 Ist dies der Fall müssen wir in unserer Schiffsliste nachschauen, weil
 der Befehl 
\series bold
COSTS
\series default
 nur von einem Schiff stammen konnte.
\end_layout

\begin_layout Standard
Angekommen geben wir nur den Preis aus, weil uns das speichern aufgrund
 der schnell schwankenden Preise nicht interessieren würde.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Nachdem wir nun den Planeten betrachtet haben, schauen wir uns das ganze
 nocheinmal von der Schiffseite aus an.
 Da die Hauptarbeit der Planet erledigt, ist hier aber nicht mehr viel wissenswe
rtes zu holen.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},numbers=left,tabsize=3"
inline false
status open

\begin_layout Plain Layout

public void goodsCommand() {
\end_layout

\begin_layout Plain Layout

	synchronized (this) {
\end_layout

\begin_layout Plain Layout

		this.con.println("Asked for goods.
\backslash
n");
\end_layout

\begin_layout Plain Layout

		if (this.pName == null) {
\end_layout

\begin_layout Plain Layout

			return;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		String[] empty = { this.name, "#" };
\end_layout

\begin_layout Plain Layout

		this.pChannel.send(GameMessage.GOODS.toMessage(empty));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public void onSdoog(Channel c, String[] goods) {
\end_layout

\begin_layout Plain Layout

	String oMessage = GameMessage.SDOOG.toString();
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < goods.length; ++i) {
\end_layout

\begin_layout Plain Layout

		oMessage += " " + goods[i];
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	this.con.println(StdFd.Messages, oMessage);
\end_layout

\begin_layout Plain Layout

	this.con.println("Available Goods: ");
\end_layout

\begin_layout Plain Layout

	for (int i = 2; i < goods.length; ++i) {
\end_layout

\begin_layout Plain Layout

		String[] split = goods[i].split("
\backslash

\backslash
.");
\end_layout

\begin_layout Plain Layout

		this.con.println(" >> " + split[0]);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Goods von der Schiffseite aus
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wie man sieht haben wir mit unserer Goodsimplementierung nicht viel zu tun.
 Wir schicken einmal die Anfrage ohne neue Waren mitzuschicken und empfangen
 die Antwort.
 Der größte Teil der Implementierung verwenden wir auf die Ausgabe.
\end_layout

\begin_layout Standard
Cost ist etwa genau so schwer.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},numbers=left,tabsize=3"
inline false
status open

\begin_layout Plain Layout

public void onTsoc(String[] way, String good, int price, int amount) {
\end_layout

\begin_layout Plain Layout

	// Nicht machen, einfach weg hauen
\end_layout

\begin_layout Plain Layout

	this.con.println("PriceInfo >> "+ good + " [price: " 				+
\end_layout

\begin_layout Plain Layout

		price + "; amount: " + amount+ "] on planet "+way[0]);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public void costCommand(String name, String good) {
\end_layout

\begin_layout Plain Layout

	if(this.peers.containsKey(name)){
\end_layout

\begin_layout Plain Layout

		String[] way = new String[this.peers.get(name).length+2];
\end_layout

\begin_layout Plain Layout

		way = this.copyInTo(this.peers.get(name), way);
\end_layout

\begin_layout Plain Layout

		way[this.peers.get(name).length] = "#";
\end_layout

\begin_layout Plain Layout

		way[this.peers.get(name).length+1] = good;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		this.pChannel.send(GameMessage.COST.toMessage(way));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Cost macht genausoviel arbeit.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Travel
\end_layout

\begin_layout Standard
Um reisen zu können, brauchen wir zunächst ein Ziel.
 Da wir, nach dem ersten andocken, nicht mit IP und Port arbeiten wollen,
 holen wir uns verdeckt mit der Frage 
\series bold
WHEREIS
\series default
 vom Planeten beides zum angefragten Planetennamen.
 Wenn wir die antwort 
\series bold
THEREIS
\series default
 bekommen, verlassen wir den Planeten und fliegen zu diesem neuen hin.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},numbers=left,tabsize=3"
inline false
status open

\begin_layout Plain Layout

SHIP:
\end_layout

\begin_layout Plain Layout

public synchronized void onThereis(String addr, int port) {
\end_layout

\begin_layout Plain Layout

	InetAddress a;
\end_layout

\begin_layout Plain Layout

	if (addr.equals("127.0.0.1")) {
\end_layout

\begin_layout Plain Layout

		a = ((UdpChannel) pChannel).getRemoteAddress();
\end_layout

\begin_layout Plain Layout

	} else {
\end_layout

\begin_layout Plain Layout

		try {
\end_layout

\begin_layout Plain Layout

			a = InetAddress.getByName(addr);
\end_layout

\begin_layout Plain Layout

		} catch (UnknownHostException e) {
\end_layout

\begin_layout Plain Layout

			this.con.println("Lost connection to the planet.");
\end_layout

\begin_layout Plain Layout

			return;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	this.gold -= Math.abs(port - ((UdpChannel) pChannel).getRemotePort());
\end_layout

\begin_layout Plain Layout

	this.mreg.removePeer(pChannel, pName);
\end_layout

\begin_layout Plain Layout

	pChannel.close();
\end_layout

\begin_layout Plain Layout

	this.pChannel = null;
\end_layout

\begin_layout Plain Layout

	this.pName = null;
\end_layout

\begin_layout Plain Layout

	this.peers.clear();
\end_layout

\begin_layout Plain Layout

	this.onDock(a, port);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

public void onTravel(String name) {
\end_layout

\begin_layout Plain Layout

	String[] remotename = 
\end_layout

\begin_layout Plain Layout

		{ this.name, GameMessage.prepareProtokoll(name) };
\end_layout

\begin_layout Plain Layout

	this.pChannel.send(GameMessage.WHEREIS.toMessage(remotename));
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Der Ablauf beim Wechsel von Planeten, Seite des Schiffes
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Rufen wir auf der Console 
\series bold
travel
\series default
 auf, übermitteln wir dem Planeten unseren Namen und den Namen des Planeten,
 zu dem wir reisen möchten.
 Bekommen wir die Antwort vom Planeten 
\series bold
THEREIS
\series default
, dann schließen wir den Channel zum Planeten, ziehen die Flugkosten ab
 und bauen eine neue Verbindung mit dem neuen Planeten auf.
 (Dieser Teil ist schon implementiert, wird hier also verwendet).
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},numbers=left,tabsize=3"
inline false
status open

\begin_layout Plain Layout

public synchronized void onWhereis(Channel c, String ship, String name)
 {
\end_layout

\begin_layout Plain Layout

	this.con.println(StdFd.Messages, GameMessage.WHEREIS + " " + name);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Channel that = this.connectedPeers.get(name);
\end_layout

\begin_layout Plain Layout

	if (that == null)
\end_layout

\begin_layout Plain Layout

		return;
\end_layout

\begin_layout Plain Layout

	UdpChannel thatU = (UdpChannel) that;
\end_layout

\begin_layout Plain Layout

	InetAddress inet = thatU.getRemoteAddress();
\end_layout

\begin_layout Plain Layout

	int port = thatU.getRemotePort();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	String[] msg = new String[2];
\end_layout

\begin_layout Plain Layout

	msg[0] = inet.getHostAddress();
\end_layout

\begin_layout Plain Layout

	msg[1] = port + "";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	this.dockedShips.remove(ship);
\end_layout

\begin_layout Plain Layout

	this.mreg.removePeer(c, ship);
\end_layout

\begin_layout Plain Layout

	c.close();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	this.updatePlanetList();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	c.send(GameMessage.THEREISPlaneten.toMessage(msg));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

public synchronized void onUndock(Channel c, String name) {
\end_layout

\begin_layout Plain Layout

	this.con.println(StdFd.Messages,GameMessage.UNDOCK +" "+name);
\end_layout

\begin_layout Plain Layout

	this.dockedShips.remove(name);
\end_layout

\begin_layout Plain Layout

	c.close();
\end_layout

\begin_layout Plain Layout

	this.updatePlanetList();
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Der Ablauf beim Wechsel von Planeten, Seite des Planeten
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Da wir in unserer Channelabstraktion nicht wissen können, was Addresse und
 Port der Verbindung sind, müssen wir an dieser Stelle in die Channel rein
 sehen und unseren UdpChannel zu rate ziehen.
 Wir suchen uns also die Addresse und den Port zu dem gefragten Planeten
 herraus und schließen die Verbindung.
 Dies machen wir, da auf der anderen Seite das Schiff nicht warten wird,
 bis wir fertig sind.
 Dieses fliegt einfach weg.
\end_layout

\begin_layout Subsubsection*
Buy
\end_layout

\begin_layout Standard
Da wir mit unserem 
\series bold
Market
\series default
 schon den logischen Teil des Handelns übernommen haben, müssen wir nun
 nur noch dem Austausch der Waren annehmen.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},numbers=left,tabsize=3"
inline false
status open

\begin_layout Plain Layout

public synchronized void onBuy(String name, int amount) {
\end_layout

\begin_layout Plain Layout

	name = GameMessage.prepareProtokoll(name);
\end_layout

\begin_layout Plain Layout

	if (this.gold <= 0) {
\end_layout

\begin_layout Plain Layout

		this.con.println(...);
\end_layout

\begin_layout Plain Layout

		return;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	String[] buy = { name, "" + amount };
\end_layout

\begin_layout Plain Layout

	this.pChannel.send(GameMessage.BUY.toMessage(buy));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public void onYub(Channel c, String name, int amount, int cost) {
\end_layout

\begin_layout Plain Layout

	this.gold -= cost;
\end_layout

\begin_layout Plain Layout

	if (this.backpack.containsKey(name)) {
\end_layout

\begin_layout Plain Layout

		this.backpack.put(name, amount + this.backpack.get(name));
\end_layout

\begin_layout Plain Layout

	} else {
\end_layout

\begin_layout Plain Layout

		this.backpack.put(name, amount);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	this.con.println(...);
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Das Schiff fragt an, dass es Waren haben möchte
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

Wenn wir den Befehl zum kaufen bekommen, gucken wir zunächst nach ob wir
 noch Gold besitzen.
 (Dies ist ein denkbar schlechter Mechanismus zum Missbrauchsschutz, entspricht
 in seiner Umsetzung aber in etwa unserem Druckservice am Fachbereich)
\end_layout

\begin_layout Standard
Ist diese Vorraussetzung erfüllt senden wir dem Planeten diese Bitte.
\end_layout

\begin_layout Standard
Bekommen wir die Antwort von Planeten, packen wir die Anzahl in unseren
 Frachtraum und ziehen den Preis von unserem Gold ab.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public synchronized void onBuy(Channel c, String name, int amount) {	
\end_layout

\begin_layout Plain Layout

	if (this.market.amount(name) >= amount) {
\end_layout

\begin_layout Plain Layout

		int cost = this.market.buy(name, amount);
\end_layout

\begin_layout Plain Layout

		String[] bill = new String[3];
\end_layout

\begin_layout Plain Layout

		bill[0] = name;
\end_layout

\begin_layout Plain Layout

		bill[1] = "" + amount;
\end_layout

\begin_layout Plain Layout

		bill[2] = "" + cost;
\end_layout

\begin_layout Plain Layout

		Message m = GameMessage.YUB.toMessage(bill);
\end_layout

\begin_layout Plain Layout

		c.send(m);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Der Planet bearbeitet den Kaufwunsch
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der Planet kann nun den Marktplatz benutzten.
 Zunächst guckt er nach, ob er überhaupt so viel zu verkaufen hat.
 Wenn dies der Fall ist, berechnet er die Kosten und schickt diese an das
 Schiff zurück.
\end_layout

\begin_layout Standard
Der eigentliche Warenaustausch findet in dieser Simulation nicht statt.
 Wenn die Nachricht eintrifft, gelten die Waren als geliefert.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsubsection*
Sell
\end_layout

\begin_layout Standard
Sell sieht äquivalent zu Buy aus.
 Wir müssen nur prüfen, dass wir so viele Waren besitzen, wie wir verkaufen
 wollen und am Schluss ziehen wir diese Menge ab und rechnen den Gewinn
 auf unseren Goldvorrat.
\end_layout

\begin_layout Standard
Da es hier nichts neues zu sehen gibt, lassen wir den Teil aus.
 Im Quellcode ist dieser Teil auch zu bewundern.
\end_layout

\begin_layout Subsection*
Bemerkung
\end_layout

\begin_layout Standard
Das einzige, dass uns an dieser Implementierung stört, ist dass die GOODS
 bestimmen sehr lange dauern kann.
 Allerdings hätte es noch eine TTL gebraucht um eine unkontrollierbare Vermehrun
g von GOODS Nachrichten zu verhindern.
 Diese Vermehrung kann ausftreten, wenn wir nur die gegebene TTL verwenden,
 weil diese nach spezifikation immer raug gesetzt werden soll, wenn wir
 über einen Knoten laufen, der die Ware anbietet [und dess ttl größer ist].
 Wenn man sich das ganze anguckt, sieht man schnell, dass ein Kreis über
 einen solchen Knoten die Nacricht endlos kreisen lassen würde.
 Dies würde aber im Vergleich zu unserer Lösung zu einem viel höheren Kommunikat
ionsaufwand führen.
 Wir finden für einen stabilen Markt an Waren unsere Lösung an sich praktischer
 als eine solche Lösung.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Unsere Lösung für den Markt ist zu der Version, die wir abgeben noch nicht
 sonderlich gut durchdacht.
 Wenn man die Waren einfach nur komplett aufkauft und wieder erkauft, dann
 kann man in null-komma-nichts wahnsinnige Massen an Gold erwirtschaften.
\end_layout

\begin_layout Standard
Hier müssen wir noch etwas an der Preisformel herumbasteln.
\end_layout

\end_body
\end_document
