\documentclass{llncs}

\usepackage[utf8]{inputenc}

\usepackage{listings}
\usepackage{amssymb}
\usepackage{amsmath}


\title{Five Message Handshake Project in Spin}
\titlerunning{Five Message Handshake}
\author{Alexander Steen \and Max Wisniewski}
\date{\today}
\institute{Institut f\"ur Informatik, FU Berlin}

\begin{document}

\maketitle

\begin{abstract}
The distributed algorithm for the mutual exclusion problem proposed by Suzuki and Kasami \cite{Suzuki:1985:DME:6110.214406} is checked
with the modelchecker \emph{Spin}. We present a modeling for the algorithm in Promela, the properties we want
to check for this algorithm and a short error analysis, why the second algorithm of Suzuki and Kasami does not work.
\end{abstract}



%% --------------------------------------
%%           Section I
%% --------------------------------------
\section{Introduction}

Skip



%% --------------------------------------
%%           Section II
%% --------------------------------------
\section{Problem / Algorithm??? \label{sec:prob}}

No problem



%% --------------------------------------
%%           Section III
%% --------------------------------------
\section{Modeling\label{sec:model}}

To determine whether the algorithms mentioned in section~\ref{sec:prob} indeed appropriately solves
the problem of mutual exclusion, we model these algorithms in promela and apply ltl modelchecking using spin.
Section~\ref{ssec:choice} justifies out choice of the spin verification suite; the following sections
describe the model itself. Finally, section~\ref{ssec:run} displays an example simulation run of the algorithms.

\subsection{Verification system~\label{ssec:choice}}

Since the algorithms described by Suzuki and Kasami use an imperative style it appears intuitive to us
that a model in promela, which itself is imperative, is best suited. Additionally, promela comes with
native support for process communication via channels. Since we are checking a distributed algorithm,
we use the channels of promela to simulate the message exchange.

\subsection{Channels}

The processes send \emph{REQUEST} and \emph{PRIVILIGE} messages which both
need to be handeld. For any atempt to enter a process sends \emph{REQUEST} to
each of its neighbors. We decided to use a mailbox kind of channel system because
this way a process does not have to iterate over many possible channels and check
each of them seperatly.

\begin{lstlisting}
chan mailbox[N] = [N] of {mtype, int, int, Queue, Array}
\end{lstlisting}

\subsection{Message}

We modeled all possible messages as one message. As can seen in
the last section. We send messages of the form
\begin{lstlisting}
(mtype, int, int, Queue, Array)
\end{lstlisting}
where
\begin{lstlisting}
mtype = {REQUEST, PRIVILIGE, REPLY}
\end{lstlisting}
are the types we use. As one can see one message type only requires
at most two of the attributes of the message. We decided to model a
message this way to send each message over the same channel. If one of
the attributes is not needed it will be filled with a dummy.


\subsection{Request Messages}

The methode \lstinline|p1| is excuted if a \emph{REQUEST} message is received.
In the modeling we decided to prioritize the receiving of \emph{REQUEST} at the
waiting points that are the \emph{remainder} and the waiting to enter the critical section.

This is neccessary to satisfy the deadlock freedom and fairness constraints.

\subsection{Global Variables}

We decided to model all local variables of the processes as a global array of variables.
We have done this out of debug reasons. This way we could check on receiving a message
if everything was the way we expected it.

\subsection{Send and Receive in Spin}

There occured an ambiguous error in our implementation when we used a wrong number of matching
variables in receiving a message. It happend some times that the received message differed from the
send message. This way some of the requesting processes where dropped from the queue and were not considered
for execution leading to a state where only one process was possible to enter the critical section.

\subsection{Queue}

We choose an implementation of a queue without a check for overflow.
\begin{lstlisting}
    insert 'insert' here
\end{lstlisting}
We could do this because in the program a number for a process is at most added once to the queue.
If we give the queue an array of size $N$ there could never occure an overflow.

\subsection{Privilege Receving}

We implemented the procedure that is called on an incomming \emph{PRIVILEGE} message as a macro.
We decided to implement it this way because we need the procedure at two points in the code.
First in the remainder of code and secondly when a process waits for the \emph{PRIVILEGE} message.
Because Spin does not support a procedure we implemented it as a macro.

\subsection{Next}

Write smth.

\subsection{Simulation of the model\label{ssec:run}}

Add blblabla diagram

%% --------------------------------------
%%           Section IV
%% --------------------------------------
\section{LTL Properties}

A Mutual Exclusion Algorithm needs to satisfy the four properties
\begin{itemize}
    \item Mutual Exclusion,
    \item Absence of Starvation,
    \item Fairness,
    \item No Unneccessary Delay
\end{itemize}
to be considered as correct.

In Spin we have to model for each of these properties one or more
LTL - Properties.

\subsection{Mutual Exclusion}

We added a variable \lstinline|incs| that is incremented before the critical section
and decremented aftarwards. If initialized to zero mutual exclusion is expressed by the
property
\begin{equation}
    \square \left( \text{\lstinline|incs|} \leq 1 \right)
\end{equation}
which is used in both implementations.

\subsection{Absence of Starvation}

For this property we need a label \lstinline|request|. We already have an array to keep track of the request,
but this flag is shortly after the critical section still set to one.
Using the counter \lstinline|incs| from the Mutual Exclusion property we can express deadlock freedom by
\begin{equation}
    \square \left( \left( \underset{0\leq i < N}{\bigvee} \text{\lstinline|Process[p[i]]@request|}\right) \Rightarrow \diamond \text{\lstinline|incs|} = 1 \right)
\end{equation}
again for both algorithms.
\subsection{Fairness}

All processes do not differ except for their Identifier. Therefore we will check the fairness constraint for the first process and the second process.
The first one because it has initially the privilage and the second one as a representive for every other process.
This time we used a label at the critical section and an array for the process id's.

Fairness can be expressed by
\begin{eqnarray}
    \square & ( \text{\lstinline|Process[p[0]]@request|} \Rightarrow \diamond \text{\lstinline|Process[p[0]]@critical|} \\
    &\land \text{\lstinline|Process[p[1]]@request|}\Rightarrow \diamond \text{\lstinline|Process[p[1]]@critical|})
\end{eqnarray}
in both algorithms.

\subsection{No Uneccessary Delay}

We check the property
\begin{eqnarray}
    \diamond & ( \square \text{\lstinline|incs|=0} \land \text{\lstinline|Process[p[0]]@request|} \land \underset{1\leq i < N}{\bigwedge} \text{\lstinline|Process[p[i]]@request|}\\
    &\Rightarrow \square \diamond(\text{\lstinline|Process[p[0]]@critical|}))
\end{eqnarray}
that means; whenever process zero is the only one who ever wants to enter the critical section it will do so infinitly many times.

%% --------------------------------------
%%           Section V
%% --------------------------------------
\section{Checking the Properties}

We could see that the first algorithm has unbounded character. We let the verifier run for some time
and never saw an error (see APPENDIX).

\subsection{Unbounded Variant}

In this section we checked the first, unbounded variant of the algorithm.
Because it is unbounded the checking will never end. We therefore checked until we reached
a certain depth in the search tree and ended it afterwards.

\subsubsection{Mutual Exclusion}

We used the above described LTL property
\begin{lstlisting}
ltl claim1 { [] (incs <= 1)}
\end{lstlisting}
and run the verifier via
\begin{lstlisting}
gcc -DVECTORSZ=4096 -DCOLLAPSE pan.c -o pan
./pan -a
\end{lstlisting}

The verifier gave the output
\begin{lstlisting}
State-vector 2072 byte, depth reached 9999, errors: 0
 40921117 states, stored
 37895505 states, matched
 78816622 transitions (= stored+matched)
 56986035 atomic steps
hash conflicts:  29156326 (resolved)
\end{lstlisting}
which at least shows, that until this depth there was no error.
The full output can be see in \ref{mc:app:unb:mutex}.

\subsubsection{Absence of Starvation}

We used the LTL property
\begin{lstlisting}
ltl claim2 { [] ((Process[p[0]]@request || Process[p[1]]@request || Process[p[2]]@request) -> <> (incs == 1))}
\end{lstlisting}
and run the verifier via
\begin{lstlisting}
gcc -DVECTORSZ=4096 -DCOLLAPSE pan.c -o pan
./pan -a -f.
\end{lstlisting}
This time we need the parameter '-f'. Otherwise it is possible for one process to never to something after wanting to enter
the critical section.
\subsection{Bounded Variant}

%% --------------------------------------
%%           Section VI
%% --------------------------------------
\section{Conclusion}

Yes.

%% --------------------------------------
%%           Section ??
%% --------------------------------------
\section{Bibliography}
\bibliographystyle{splncs}

\bibliography{mc}

\appendix

\section{Unbonded Algorithm Output}

\subsection{Mutual Exclusion}
\ref{mc:app:unb:mutex}

\begin{lstlisting}

Alex@hildegunst ~
$ ./pan -a
error: max search depth too small
Depth=    9999 States=    1e+06 Transitions= 1.92e+06 Memory=   146.812 t=     7.21 R=   1e+05
Depth=    9999 States=    2e+06 Transitions= 3.83e+06 Memory=   228.453 t=     14.6 R=   1e+05
Depth=    9999 States=    3e+06 Transitions= 5.74e+06 Memory=   311.656 t=     22.4 R=   1e+05
Depth=    9999 States=    4e+06 Transitions= 7.68e+06 Memory=   402.281 t=     30.4 R=   1e+05
Depth=    9999 States=    5e+06 Transitions= 9.63e+06 Memory=   503.453 t=     38.3 R=   1e+05
Depth=    9999 States=    6e+06 Transitions= 1.16e+07 Memory=   582.750 t=     45.8 R=   1e+05
Depth=    9999 States=    7e+06 Transitions= 1.35e+07 Memory=   670.250 t=     53.1 R=   1e+05
Depth=    9999 States=    8e+06 Transitions= 1.54e+07 Memory=   744.859 t=     60.6 R=   1e+05
Depth=    9999 States=    9e+06 Transitions= 1.73e+07 Memory=   827.672 t=     68.3 R=   1e+05
Depth=    9999 States=    1e+07 Transitions= 1.93e+07 Memory=   914.000 t=     76.3 R=   1e+05
Depth=    9999 States=  1.1e+07 Transitions= 2.12e+07 Memory=   997.203 t=     83.9 R=   1e+05
Depth=    9999 States=  1.2e+07 Transitions= 2.31e+07 Memory=  1082.750 t=     91.5 R=   1e+05
Depth=    9999 States=  1.3e+07 Transitions= 2.51e+07 Memory=  1170.250 t=     99.2 R=   1e+05
Depth=    9999 States=  1.4e+07 Transitions=  2.7e+07 Memory=  1255.016 t=      107 R=   1e+05
Depth=    9999 States=  1.5e+07 Transitions=  2.9e+07 Memory=  1340.172 t=      115 R=   1e+05
Depth=    9999 States=  1.6e+07 Transitions= 3.09e+07 Memory=  1423.766 t=      123 R=   1e+05
Depth=    9999 States=  1.7e+07 Transitions= 3.28e+07 Memory=  1507.359 t=      131 R=   1e+05
Depth=    9999 States=  1.8e+07 Transitions= 3.47e+07 Memory=  1593.297 t=      139 R=   1e+05
Depth=    9999 States=  1.9e+07 Transitions= 3.67e+07 Memory=  1677.672 t=      146 R=   1e+05
Depth=    9999 States=    2e+07 Transitions= 3.86e+07 Memory=  1756.969 t=      154 R=   1e+05
Depth=    9999 States=  2.1e+07 Transitions= 4.05e+07 Memory=  1840.172 t=      162 R=   1e+05
Depth=    9999 States=  2.2e+07 Transitions= 4.25e+07 Memory=  1921.422 t=      170 R=   1e+05
Depth=    9999 States=  2.3e+07 Transitions= 4.44e+07 Memory=  2001.891 t=      178 R=   1e+05
Depth=    9999 States=  2.4e+07 Transitions= 4.63e+07 Memory=  2084.703 t=      186 R=   1e+05
Depth=    9999 States=  2.5e+07 Transitions= 4.83e+07 Memory=  2168.297 t=      194 R=   1e+05
Depth=    9999 States=  2.6e+07 Transitions= 5.02e+07 Memory=  2253.453 t=      202 R=   1e+05
Depth=    9999 States=  2.7e+07 Transitions= 5.21e+07 Memory=  2321.812 t=      210 R=   1e+05
Depth=    9999 States=  2.8e+07 Transitions=  5.4e+07 Memory=  2395.641 t=      218 R=   1e+05
Depth=    9999 States=  2.9e+07 Transitions= 5.59e+07 Memory=  2474.156 t=      226 R=   1e+05
Depth=    9999 States=    3e+07 Transitions= 5.79e+07 Memory=  2560.094 t=      234 R=   1e+05
Depth=    9999 States=  3.1e+07 Transitions= 5.98e+07 Memory=  2642.906 t=      242 R=   1e+05
Depth=    9999 States=  3.2e+07 Transitions= 6.17e+07 Memory=  2726.109 t=      251 R=   1e+05
Depth=    9999 States=  3.3e+07 Transitions= 6.36e+07 Memory=  2804.234 t=      259 R=   1e+05
Depth=    9999 States=  3.4e+07 Transitions= 6.55e+07 Memory=  2880.797 t=      267 R=   1e+05
pan: resizing hashtable to -w26..  done
Depth=    9999 States=  3.5e+07 Transitions= 6.74e+07 Memory=  3211.406 t=      282 R=   1e+05
Depth=    9999 States=  3.6e+07 Transitions= 6.94e+07 Memory=  3302.031 t=      290 R=   1e+05
Depth=    9999 States=  3.7e+07 Transitions= 7.13e+07 Memory=  3382.500 t=      298 R=   1e+05
tate-vector 2072 byte, depth reached 9999, errors: 0
 40921117 states, stored
 37895505 states, matched
 78816622 transitions (= stored+matched)
 56986035 atomic steps
hash conflicts:  29156326 (resolved)State-vector 2072 byte, depth reached 9999, errors: 0
 40921117 states, stored
 37895505 states, matched
 78816622 transitions (= stored+matched)
 56986035 atomic steps
hash conflicts:  29156326 (resolved)
Depth=    9999 States=  3.9e+07 Transitions= 7.51e+07 Memory=  3546.172 t=      314 R=   1e+05
Depth=    9999 States=    4e+07 Transitions= 7.71e+07 Memory=  3636.016 t=      322 R=   1e+05
pan: out of memory

hint: to reduce memory, recompile with
  -DMA=2072   # better/slower compression, or
  -DBITSTATE # supertrace, approximation

(Spin Version 6.2.3 -- 24 October 2012)
Warning: Search not completed
        + Partial Order Reduction
        + Compression

Full statespace search for:
        never claim             + (claim1)
        assertion violations    + (if within scope of claim)
        acceptance   cycles     + (fairness disabled)
        invalid end states      - (disabled by never claim)

State-vector 2072 byte, depth reached 9999, errors: 0
 40921117 states, stored
 37895505 states, matched
 78816622 transitions (= stored+matched)
 56986035 atomic steps
hash conflicts:  29156326 (resolved)

Stats on memory usage (in Megabytes):
81641.175       equivalent memory usage for states (stored*(State-vector + overhead))
 3442.784       actual memory usage for states (compression: 4.22%)
                state-vector as stored = 68 byte + 20 byte overhead
  256.000       memory used for hash table (-w26)
    0.382       memory used for DFS stack (-m10000)
    1.840       memory lost to fragmentation
 3697.344       total actual memory usage


nr of templates: [ 0:globals 1:chans 2:procs ]
collapse counts: [ 0:4015087 2:13 3:3852 4:1 ]

pan: elapsed time 329 seconds
pan: rate 124449.14 states/second
\end{lstlisting}

\end{document}
